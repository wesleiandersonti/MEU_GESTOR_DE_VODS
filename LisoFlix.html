<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LisoFlix</title>
<style>
  @import url("https://fonts.cdnfonts.com/css/netflix-sans");

  :root {
    --netflix-red: #e50914;
    --netflix-black: #000000;
    --netflix-dark-gray: #141414;
    --netflix-medium-gray: #333333;
    --netflix-light-gray: #808080;
    --netflix-white: #ffffff;
  }

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    background-color: var(--netflix-black);
    font-family: "Netflix Sans", "Helvetica Neue", Arial, sans-serif;
    color: var(--netflix-white);
    overflow-x: hidden;
  }

  header {
    background-color: rgba(0, 0, 0, 1);
    padding: 14px 4%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    z-index: 1000;
    transition: background-color 0.3s ease;
  }

  .logo {
    font-size: 1.8em;
    font-weight: bold;
    color: var(--netflix-white);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
    flex-shrink: 0;
  }

  .logo span {
    color: var(--netflix-red);
    font-style: italic;
    transform: skewX(-10deg);
    display: inline-block;
  }

  nav {
    display: flex;
    gap: 14px;
    overflow-x: auto;
    scrollbar-width: none;
    -ms-overflow-style: none;
    flex-grow: 1;
    justify-content: flex-end;
  }
  nav::-webkit-scrollbar {
    display: none;
  }

  nav button {
    background: none;
    border: none;
    color: var(--netflix-light-gray);
    font-size: 1em;
    font-weight: bold;
    cursor: pointer;
    padding: 6px 0;
    border-bottom: 3px solid transparent;
    transition: color 0.3s ease, border-bottom 0.3s ease;
    flex-shrink: 0;
  }

  nav button.active {
    color: var(--netflix-white);
    border-bottom: 3px solid var(--netflix-red);
  }

  nav button#tab-continue {
    background: linear-gradient(135deg, #e50914 0%, #b20710 100%);
    color: white;
    font-weight: bold;
    border-radius: 4px;
    padding: 8px 16px;
    margin-left: 10px;
    transition: all 0.3s ease;
  }

  nav button#tab-continue:hover {
    background: linear-gradient(135deg, #ff0a16 0%, #d40812 100%);
    transform: scale(1.05);
    box-shadow: 0 4px 15px rgba(229, 9, 20, 0.4);
  }

  .hero-banner {
    position: relative;
    height: 60vh;
    background: linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.8)), url("https://image.tmdb.org/t/p/original/xOMo8BRK7PfcJv9JCnx7s5hj0PX.jpg");
    background-size: cover;
    background-position: center;
    display: flex;
    align-items: center;
    margin-bottom: 20px;
    padding: 0 4%;
  }
  
  .hero-content {
    max-width: 500px;
    color: var(--netflix-white);
  }
  
  .hero-title {
    font-size: 3rem;
    font-weight: bold;
    margin-bottom: 15px;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
  }
  
  .hero-description {
    font-size: 1.2rem;
    margin-bottom: 25px;
    line-height: 1.4;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
  }
  
  .hero-buttons {
    display: flex;
    gap: 15px;
  }
  
  .btn-play, .btn-info {
    padding: 12px 30px;
    border: none;
    border-radius: 6px;
    font-size: 1.1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .btn-play {
    background: var(--netflix-white);
    color: var(--netflix-black);
  }
  
  .btn-play:hover {
    background: rgba(255,255,255,0.8);
  }
  
  .btn-info {
    background: rgba(109, 109, 110, 0.7);
    color: var(--netflix-white);
  }
  
  .btn-info:hover {
    background: rgba(109, 109, 110, 0.5);
  }

  .carousel, .grid {
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    gap: 8px;
    padding: 0 4% 20px 4%;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }
  .carousel::-webkit-scrollbar {
    display: none;
  }
  .grid {
    flex-wrap: wrap;
    justify-content: center;
    overflow-x: hidden;
  }
  .item {
    width: 200px;
    background: transparent;
    border-radius: 8px;
    overflow: hidden;
    text-align: left;
    flex-shrink: 0;
    position: relative;
    transition: transform 0.3s ease;
    cursor: pointer;
  }
  .item:hover {
    transform: scale(1.08);
    z-index: 10;
  }
  .item img {
    width: 100%;
    height: 300px;
    object-fit: cover;
    border-radius: 8px;
  }
  .item p {
    margin: 8px 0;
    font-size: 0.9rem;
    color: var(--netflix-light-gray);
    font-weight: 500;
  }
  .img-container {
    position: relative;
    overflow: hidden;
    border-radius: 8px;
  }
  .fav-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    font-size: 1.4em;
    cursor: pointer;
    text-shadow: 0 0 8px black;
    user-select: none;
    background: rgba(0,0,0,0.6);
    border-radius: 50%;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
  }
  .fav-btn:hover {
    background: rgba(0,0,0,0.8);
    transform: scale(1.1);
  }
  .category {
    margin-bottom: 40px;
  }
  .category h2 {
    margin: 0 0 15px 4%;
    font-size: 1.4em;
    color: var(--netflix-white);
    font-weight: bold;
  }
  
  .loading-spinner {
    display: inline-block;
    width: 40px;
    height: 40px;
    border: 3px solid var(--netflix-medium-gray);
    border-top: 3px solid var(--netflix-red);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 20px auto;
    text-align: center;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .update-info {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 0.8rem;
    color: var(--netflix-light-gray);
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .btn-atualizar {
    background: var(--netflix-red);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
  }

  .btn-atualizar:hover {
    background: #ff0a16;
  }

  .btn-config {
    background: #2196F3;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: background 0.3s ease;
  }

  .btn-config:hover {
    background: #1976D2;
  }

  .offline-badge {
    background: var(--netflix-red);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 0.7rem;
    margin-left: 10px;
  }

  video {
    width: 100%;
    max-height: 50vh;
    display: none;
    margin-bottom: 10px;
  }
  .btn-voltar {
    margin: 10px;
    padding: 8px 16px;
    background: var(--netflix-red);
    border: none;
    color: var(--netflix-white);
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
  }
  #conteudo {
    padding: 0;
  }
  .episodes button {
    display: block;
    width: 100%;
    margin: 4px 0;
    background: var(--netflix-medium-gray);
    color: var(--netflix-white);
    border: none;
    padding: 10px;
    border-radius: 6px;
    text-align: left;
    cursor: pointer;
  }
  #player-controls {
    display: none;
    justify-content: center;
    gap: 10px;
    margin: 10px 0;
    flex-wrap: wrap;
  }
  #player-controls button {
    background: var(--netflix-red);
    color: var(--netflix-white);
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    font-weight: bold;
    cursor: pointer;
  }

  @media (max-width: 768px) {
    .hero-content {
      margin-left: 0;
    }
    .hero-title {
      font-size: 2rem;
    }
    .hero-description {
      font-size: 1rem;
    }
    .carousel, .grid {
      padding: 0 20px 20px 20px;
    }
    .category h2 {
      margin: 0 0 15px 20px;
    }
    .item {
      width: 150px;
    }
    .item img {
      height: 225px;
    }
  }
</style>
</head>
<body>

<header id="header">
  <div class="logo"><span>L</span>iso<span>F</span>lix</div>
  <nav>
    <button id="tab-home" class="active">In√≠cio</button>
    <button id="tab-filmes">Filmes</button>
    <button id="tab-series">S√©ries</button>
    <button id="tab-favoritos">Favoritos</button>
    <button id="tab-continue" onclick="openContinueWatchingModal()" style="background: #e50914; color: white; font-weight: bold;">üì∫ Continuar</button>
  </nav>
</header>

<div id="update-info" class="update-info" style="display: none;">
  <span id="last-update">Nunca atualizado</span>
  <button class="btn-atualizar" onclick="atualizarDados()">Atualizar</button>
  <button class="btn-config" onclick="openConfigModal()" style="background: #2196F3; margin-left: 10px;">‚öôÔ∏è Configurar Links</button>
</div>

<div id="player-controls">
  <button onclick="playerPlay()">Play</button>
  <button onclick="playerPause()">Pause</button>
  <button onclick="playerStop()">Stop</button>
  <button onclick="playerBack()">-10s</button>
  <button onclick="playerForward()">+10s</button>
</div>
<video controls="" id="player"></video>

<div id="conteudo">
  <div style="text-align: center; padding: 50px;"><div class="loading-spinner"></div></div>
</div>

<script>
  const header = document.getElementById("header");
  const homeBtn = document.getElementById("tab-home");
  const filmesBtn = document.getElementById("tab-filmes");
  const seriesBtn = document.getElementById("tab-series");
  const favoritosBtn = document.getElementById("tab-favoritos");
  const conteudoDiv = document.getElementById("conteudo");

  let filmes = {};
  let series = {};
  let streamBase = "";
  let urlG = "http://flayto.click";
  let userG = "felipe96452";
  let passG = "8761dias";
  let favoritos = JSON.parse(localStorage.getItem("favoritos") || "[]");

  // IndexedDB Configuration
  const DB_NAME = 'LisoFlixDB';
  const DB_VERSION = 3; // Incrementado para adicionar store de cache de v√≠deo
  let db = null;
  
  // Configura√ß√£o de links M3U8 personalizados (apenas usu√°rio pode configurar)
  let customM3U8Links = [];
  
  // Cache de posi√ß√£o de v√≠deos
  let videoCache = {};

  // Initialize IndexedDB
  function initDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        db = request.result;
        resolve(db);
      };
      
      request.onupgradeneeded = (event) => {
        const database = event.target.result;
        
        // Store for movies
        if (!database.objectStoreNames.contains('filmes')) {
          const filmesStore = database.createObjectStore('filmes', { keyPath: 'stream_id' });
          filmesStore.createIndex('category_name', 'category_name', { unique: false });
          filmesStore.createIndex('name', 'name', { unique: false });
        }
        
        // Store for series
        if (!database.objectStoreNames.contains('series')) {
          const seriesStore = database.createObjectStore('series', { keyPath: 'series_id' });
          seriesStore.createIndex('category_name', 'category_name', { unique: false });
          seriesStore.createIndex('name', 'name', { unique: false });
        }
        
        // Store for metadata
        if (!database.objectStoreNames.contains('metadata')) {
          database.createObjectStore('metadata', { keyPath: 'key' });
        }
        
        // Store for custom M3U8 links (user configured only)
        if (!database.objectStoreNames.contains('customLinks')) {
          const linksStore = database.createObjectStore('customLinks', { keyPath: 'id', autoIncrement: true });
          linksStore.createIndex('name', 'name', { unique: false });
          linksStore.createIndex('url', 'url', { unique: true });
          linksStore.createIndex('lastPlayed', 'lastPlayed', { unique: false });
        }
        
        // Store for playback history (tracks what was played and when)
        if (!database.objectStoreNames.contains('playbackHistory')) {
          const historyStore = database.createObjectStore('playbackHistory', { keyPath: 'id', autoIncrement: true });
          historyStore.createIndex('contentName', 'contentName', { unique: false });
          historyStore.createIndex('contentUrl', 'contentUrl', { unique: false });
          historyStore.createIndex('timestamp', 'timestamp', { unique: false });
          historyStore.createIndex('source', 'source', { unique: false }); // 'custom' ou 'api'
        }
        
        // Store for video progress cache (saves position for resume)
        if (!database.objectStoreNames.contains('videoProgress')) {
          const progressStore = database.createObjectStore('videoProgress', { keyPath: 'videoUrl' });
          progressStore.createIndex('contentName', 'contentName', { unique: false });
          progressStore.createIndex('lastPosition', 'lastPosition', { unique: false });
          progressStore.createIndex('duration', 'duration', { unique: false });
          progressStore.createIndex('lastUpdated', 'lastUpdated', { unique: false });
          progressStore.createIndex('percentage', 'percentage', { unique: false });
        }
        
        // Store for offline video cache metadata
        if (!database.objectStoreNames.contains('offlineCache')) {
          const offlineStore = database.createObjectStore('offlineCache', { keyPath: 'videoUrl' });
          offlineStore.createIndex('contentName', 'contentName', { unique: false });
          offlineStore.createIndex('cachedSegments', 'cachedSegments', { unique: false });
          offlineStore.createIndex('cacheSize', 'cacheSize', { unique: false });
          offlineStore.createIndex('lastAccessed', 'lastAccessed', { unique: false });
        }
      };
    });
  }

  // Save data to IndexedDB
  async function saveToDB(storeName, data) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([storeName], 'readwrite');
      const store = transaction.objectStore(storeName);
      
      // Clear existing data
      store.clear();
      
      // Add new data
      data.forEach(item => {
        store.put(item);
      });
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
    });
  }

  // Load data from IndexedDB
  async function loadFromDB(storeName) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction([storeName], 'readonly');
      const store = transaction.objectStore(storeName);
      const request = store.getAll();
      
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }

  // Save metadata
  async function saveMetadata(key, value) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['metadata'], 'readwrite');
      const store = transaction.objectStore('metadata');
      store.put({ key, value });
      
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
    });
  }

  // Load metadata
  async function loadMetadata(key) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['metadata'], 'readonly');
      const store = transaction.objectStore('metadata');
      const request = store.get(key);
      
      request.onsuccess = () => resolve(request.result ? request.result.value : null);
      request.onerror = () => reject(request.error);
    });
  }

  // Update UI with last update info
  async function updateLastUpdateInfo() {
    const lastUpdate = await loadMetadata('lastUpdate');
    const updateInfoDiv = document.getElementById('update-info');
    const lastUpdateSpan = document.getElementById('last-update');
    
    if (lastUpdate) {
      const date = new Date(lastUpdate);
      const formatted = date.toLocaleString('pt-BR');
      lastUpdateSpan.textContent = `Atualizado: ${formatted}`;
      updateInfoDiv.style.display = 'flex';
    } else {
      lastUpdateSpan.textContent = 'Nunca atualizado';
      updateInfoDiv.style.display = 'flex';
    }
  }

  // Force update from API
  async function atualizarDados() {
    if (confirm('Isso ir√° buscar os dados mais recentes da API. Continuar?')) {
      await renderTelaPrincipal(true);
    }
  }

  // ============================================
  // CUSTOM M3U8 LINKS MANAGEMENT
  // ============================================
  
  // Add custom M3U8 link
  async function addCustomM3U8Link(name, url) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['customLinks'], 'readwrite');
      const store = transaction.objectStore('customLinks');
      
      const link = {
        name: name,
        url: url,
        addedDate: new Date().toISOString(),
        lastPlayed: null,
        playCount: 0
      };
      
      const request = store.add(link);
      
      request.onsuccess = () => {
        console.log('Link M3U8 adicionado:', name);
        resolve(request.result);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // Load all custom M3U8 links
  async function loadCustomM3U8Links() {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['customLinks'], 'readonly');
      const store = transaction.objectStore('customLinks');
      const request = store.getAll();
      
      request.onsuccess = () => {
        customM3U8Links = request.result;
        resolve(request.result);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // Update last played timestamp
  async function updateLinkLastPlayed(linkId) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['customLinks'], 'readwrite');
      const store = transaction.objectStore('customLinks');
      
      const getRequest = store.get(linkId);
      
      getRequest.onsuccess = () => {
        const link = getRequest.result;
        if (link) {
          link.lastPlayed = new Date().toISOString();
          link.playCount = (link.playCount || 0) + 1;
          
          const updateRequest = store.put(link);
          updateRequest.onsuccess = () => resolve();
          updateRequest.onerror = () => reject(updateRequest.error);
        } else {
          resolve();
        }
      };
      getRequest.onerror = () => reject(getRequest.error);
    });
  }
  
  // Delete custom link
  async function deleteCustomM3U8Link(linkId) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['customLinks'], 'readwrite');
      const store = transaction.objectStore('customLinks');
      
      const request = store.delete(linkId);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  // ============================================
  // PLAYBACK HISTORY
  // ============================================
  
  // Save playback to history
  async function savePlaybackHistory(contentName, contentUrl, source) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['playbackHistory'], 'readwrite');
      const store = transaction.objectStore('playbackHistory');
      
      const historyEntry = {
        contentName: contentName,
        contentUrl: contentUrl,
        timestamp: new Date().toISOString(),
        source: source // 'custom' ou 'api'
      };
      
      const request = store.add(historyEntry);
      
      request.onsuccess = () => {
        console.log('Reprodu√ß√£o salva no hist√≥rico:', contentName);
        resolve(request.result);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // Load playback history
  async function loadPlaybackHistory(limit = 50) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['playbackHistory'], 'readonly');
      const store = transaction.objectStore('playbackHistory');
      const index = store.index('timestamp');
      
      const request = index.openCursor(null, 'prev');
      const results = [];
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor && results.length < limit) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // ============================================
  // CONFIGURATION INTERFACE
  // ============================================
  
  // Open configuration modal for custom links
  function openConfigModal() {
    const modal = document.createElement('div');
    modal.id = 'config-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Netflix Sans", "Helvetica Neue", Arial, sans-serif;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
      background: #1a1a1a;
      width: 90%;
      max-width: 700px;
      max-height: 80vh;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
    `;
    
    content.innerHTML = `
      <div style="background: #e50914; padding: 20px; display: flex; justify-content: space-between; align-items: center;">
        <h2 style="margin: 0; color: white; font-size: 1.5em;">‚öôÔ∏è Configura√ß√£o de Links M3U8</h2>
        <button onclick="closeConfigModal()" style="background: transparent; border: none; color: white; font-size: 24px; cursor: pointer;">√ó</button>
      </div>
      
      <div style="padding: 20px; max-height: calc(80vh - 140px); overflow-y: auto;">
        <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
          <h3 style="margin: 0 0 15px 0; color: #e50914; font-size: 1.1em;">‚ûï Adicionar Novo Link</h3>
          <div style="display: flex; gap: 10px; flex-wrap: wrap;">
            <input type="text" id="new-link-name" placeholder="Nome do canal/conte√∫do" style="flex: 1; min-width: 200px; padding: 10px; border: 1px solid #444; background: #1a1a1a; color: white; border-radius: 4px;">
            <input type="text" id="new-link-url" placeholder="URL M3U8" style="flex: 2; min-width: 300px; padding: 10px; border: 1px solid #444; background: #1a1a1a; color: white; border-radius: 4px;">
            <button onclick="addNewLinkFromModal()" style="padding: 10px 20px; background: #e50914; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Adicionar</button>
          </div>
        </div>
        
        <div id="custom-links-list" style="margin-top: 20px;">
          <h3 style="color: #fff; margin-bottom: 15px;">üì∫ Meus Links Configurados</h3>
          <div id="links-container" style="display: flex; flex-direction: column; gap: 10px;">
            <p style="color: #888; text-align: center; padding: 20px;">Carregando links...</p>
          </div>
        </div>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #333;">
          <h3 style="color: #fff; margin-bottom: 15px;">üìä Estat√≠sticas</h3>
          <div id="config-stats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; text-align: center;">
              <div style="font-size: 24px; color: #e50914; font-weight: bold;" id="stat-total-links">0</div>
              <div style="color: #888; font-size: 12px;">Links Configurados</div>
            </div>
            <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; text-align: center;">
              <div style="font-size: 24px; color: #e50914; font-weight: bold;" id="stat-total-plays">0</div>
              <div style="color: #888; font-size: 12px;">Reprodu√ß√µes Totais</div>
            </div>
          </div>
        </div>
      </div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
    
    // Load links
    loadAndDisplayCustomLinks();
  }
  
  // Close configuration modal
  function closeConfigModal() {
    const modal = document.getElementById('config-modal');
    if (modal) {
      modal.remove();
    }
  }
  
  // Load and display custom links in modal
  async function loadAndDisplayCustomLinks() {
    try {
      const links = await loadCustomM3U8Links();
      const container = document.getElementById('links-container');
      const statTotalLinks = document.getElementById('stat-total-links');
      
      if (statTotalLinks) {
        statTotalLinks.textContent = links.length;
      }
      
      if (links.length === 0) {
        container.innerHTML = `
          <div style="text-align: center; padding: 40px; color: #666;">
            <p style="font-size: 16px; margin-bottom: 10px;">Nenhum link M3U8 configurado ainda.</p>
            <p style="font-size: 13px;">Adicione seus links personalizados acima.</p>
          </div>
        `;
        return;
      }
      
      let totalPlays = 0;
      container.innerHTML = links.map(link => {
        totalPlays += link.playCount || 0;
        const lastPlayed = link.lastPlayed 
          ? new Date(link.lastPlayed).toLocaleString('pt-BR') 
          : 'Nunca reproduzido';
        
        return `
          <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #e50914;">
            <div style="flex: 1;">
              <div style="font-weight: bold; color: #fff; margin-bottom: 5px;">${link.name}</div>
              <div style="font-size: 12px; color: #888; word-break: break-all;">${link.url}</div>
              <div style="font-size: 11px; color: #666; margin-top: 5px;">
                <span style="color: #e50914;">‚ñ∂ ${link.playCount || 0} reprodu√ß√µes</span> ‚Ä¢ √öltima: ${lastPlayed}
              </div>
            </div>
            <div style="display: flex; gap: 8px; margin-left: 15px;">
              <button onclick="playCustomLink(${link.id}, '${link.name}', '${link.url}')" style="padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">‚ñ∂ Reproduzir</button>
              <button onclick="deleteLinkFromModal(${link.id})" style="padding: 8px 15px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">üóëÔ∏è Excluir</button>
            </div>
          </div>
        `;
      }).join('');
      
      const statTotalPlays = document.getElementById('stat-total-plays');
      if (statTotalPlays) {
        statTotalPlays.textContent = totalPlays;
      }
    } catch (error) {
      console.error('Erro ao carregar links:', error);
      document.getElementById('links-container').innerHTML = `
        <p style="color: #f44336; text-align: center; padding: 20px;">Erro ao carregar links. Tente novamente.</p>
      `;
    }
  }
  
  // Add new link from modal
  async function addNewLinkFromModal() {
    const nameInput = document.getElementById('new-link-name');
    const urlInput = document.getElementById('new-link-url');
    
    const name = nameInput.value.trim();
    const url = urlInput.value.trim();
    
    if (!name || !url) {
      alert('Por favor, preencha o nome e a URL do link.');
      return;
    }
    
    if (!url.endsWith('.m3u8') && !url.includes('.m3u8?')) {
      if (!confirm('A URL n√£o parece ser um arquivo M3U8. Deseja adicionar mesmo assim?')) {
        return;
      }
    }
    
    try {
      await addCustomM3U8Link(name, url);
      nameInput.value = '';
      urlInput.value = '';
      await loadAndDisplayCustomLinks();
      alert('Link adicionado com sucesso!');
    } catch (error) {
      alert('Erro ao adicionar link. Verifique se a URL j√° n√£o existe.');
    }
  }
  
  // Play custom link
  async function playCustomLink(linkId, name, url) {
    try {
      // Update last played
      await updateLinkLastPlayed(linkId);
      
      // Save to playback history
      await savePlaybackHistory(name, url, 'custom');
      
      // Open player
      abrirPlayer(url, name, 'custom');
      
      console.log('Reproduzindo link personalizado:', name);
    } catch (error) {
      console.error('Erro ao reproduzir link:', error);
      alert('Erro ao reproduzir o link. Tente novamente.');
    }
  }
  
  // Delete link from modal
  async function deleteLinkFromModal(linkId) {
    if (!confirm('Tem certeza que deseja excluir este link?')) {
      return;
    }
    
    try {
      await deleteCustomM3U8Link(linkId);
      await loadAndDisplayCustomLinks();
    } catch (error) {
      alert('Erro ao excluir link.');
    }
  }

  window.addEventListener("scroll", () => {
    if (window.scrollY > 30) {
      header.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
    } else {
      header.style.backgroundColor = "rgba(0, 0, 0, 1)";
    }
  });

  function playerPlay() { document.getElementById("player").play(); }
  function playerPause() { document.getElementById("player").pause(); }
  function playerStop() {
    const p = document.getElementById("player");
    p.pause(); p.currentTime = 0;
  }
  function playerBack() { const p = document.getElementById("player"); p.currentTime -= 10; }
  function playerForward() { const p = document.getElementById("player"); p.currentTime += 10; }

  function exibirPlayer(link, item = null, source = 'api') {
    const player = document.getElementById("player");
    const controls = document.getElementById("player-controls");
    const contentName = item ? item.name : 'Conte√∫do desconhecido';
    
    // Setup auto-save for this video
    setupVideoAutoSave(player, link, contentName);
    
    // Load saved progress
    loadVideoProgress(link).then(progress => {
      if (progress && progress.lastPosition > 10) { // Only resume if watched more than 10 seconds
        const resume = confirm(
          `Voc√™ parou de assistir "${contentName}" em ${formatTime(progress.lastPosition)}.\n\n` +
          `Deseja continuar de onde parou?`
        );
        
        if (resume) {
          player.src = link;
          player.style.display = "block";
          controls.style.display = "flex";
          
          // Set time after metadata is loaded
          player.addEventListener('loadedmetadata', function onLoaded() {
            player.currentTime = progress.lastPosition;
            player.removeEventListener('loadedmetadata', onLoaded);
            player.play();
            console.log(`Retomando v√≠deo em: ${formatTime(progress.lastPosition)}`);
          });
          
          window.scrollTo({ top: 0, behavior: "smooth" });
          if (item) registrarUltimo(item);
          
          // Save to playback history
          savePlaybackHistory(contentName, link, source).catch(err => {
            console.log('Erro ao salvar hist√≥rico:', err);
          });
          return;
        }
      }
      
      // Normal play (no saved position or user chose not to resume)
      player.src = link;
      player.style.display = "block";
      controls.style.display = "flex";
      player.play();
      window.scrollTo({ top: 0, behavior: "smooth" });
      if (item) registrarUltimo(item);
      
      // Save to playback history
      savePlaybackHistory(contentName, link, source).catch(err => {
        console.log('Erro ao salvar hist√≥rico:', err);
      });
    }).catch(err => {
      console.log('Erro ao carregar progresso:', err);
      // Fallback to normal play
      player.src = link;
      player.style.display = "block";
      controls.style.display = "flex";
      player.play();
      window.scrollTo({ top: 0, behavior: "smooth" });
      if (item) registrarUltimo(item);
    });
  }

  function ocultarPlayer() {
    const player = document.getElementById("player");
    const controls = document.getElementById("player-controls");
    player.pause();
    player.removeAttribute("src");
    player.load();
    player.style.display = "none";
    controls.style.display = "none";
  }

  // ============================================
  // VIDEO PROGRESS CACHE SYSTEM
  // ============================================
  
  // Save video progress to IndexedDB
  async function saveVideoProgress(videoUrl, contentName, currentTime, duration) {
    if (!db) await initDB();
    if (!videoUrl || currentTime < 5) return; // Don't save if less than 5 seconds
    
    const percentage = duration > 0 ? (currentTime / duration) * 100 : 0;
    
    // Don't save if video is finished (95%+ watched)
    if (percentage >= 95) {
      await deleteVideoProgress(videoUrl);
      return;
    }
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['videoProgress'], 'readwrite');
      const store = transaction.objectStore('videoProgress');
      
      const progress = {
        videoUrl: videoUrl,
        contentName: contentName,
        lastPosition: currentTime,
        duration: duration,
        percentage: percentage,
        lastUpdated: new Date().toISOString()
      };
      
      const request = store.put(progress);
      
      request.onsuccess = () => {
        console.log(`Progresso salvo: ${contentName} - ${formatTime(currentTime)} (${percentage.toFixed(1)}%)`);
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // Load video progress from IndexedDB
  async function loadVideoProgress(videoUrl) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['videoProgress'], 'readonly');
      const store = transaction.objectStore('videoProgress');
      const request = store.get(videoUrl);
      
      request.onsuccess = () => {
        resolve(request.result || null);
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // Delete video progress
  async function deleteVideoProgress(videoUrl) {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['videoProgress'], 'readwrite');
      const store = transaction.objectStore('videoProgress');
      const request = store.delete(videoUrl);
      
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
  
  // Get all videos with saved progress
  async function getAllSavedProgress() {
    if (!db) await initDB();
    
    return new Promise((resolve, reject) => {
      const transaction = db.transaction(['videoProgress'], 'readonly');
      const store = transaction.objectStore('videoProgress');
      const index = store.index('lastUpdated');
      const request = index.openCursor(null, 'prev');
      
      const results = [];
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
  
  // Setup video event listeners for auto-save
  function setupVideoAutoSave(player, videoUrl, contentName) {
    let saveInterval;
    let lastSavedTime = 0;
    
    // Save every 5 seconds while playing
    player.addEventListener('play', () => {
      saveInterval = setInterval(() => {
        if (player.currentTime > lastSavedTime + 5) {
          saveVideoProgress(videoUrl, contentName, player.currentTime, player.duration);
          lastSavedTime = player.currentTime;
        }
      }, 5000);
    });
    
    // Save immediately when paused
    player.addEventListener('pause', () => {
      clearInterval(saveInterval);
      saveVideoProgress(videoUrl, contentName, player.currentTime, player.duration);
    });
    
    // Save when video ends
    player.addEventListener('ended', () => {
      clearInterval(saveInterval);
      deleteVideoProgress(videoUrl);
    });
    
    // Save before page unload
    window.addEventListener('beforeunload', () => {
      saveVideoProgress(videoUrl, contentName, player.currentTime, player.duration);
    });
  }
  
  // Format time helper
  function formatTime(seconds) {
    if (!seconds || seconds < 0) return '00:00';
    const hrs = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hrs > 0) {
      return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  
  // Show continue watching banner
  async function showContinueWatching() {
    const savedVideos = await getAllSavedProgress();
    if (savedVideos.length === 0) return;
    
    // Filter videos with meaningful progress (more than 1% and less than 95%)
    const inProgress = savedVideos.filter(v => v.percentage > 1 && v.percentage < 95);
    if (inProgress.length === 0) return;
    
    // Create banner
    const banner = document.createElement('div');
    banner.id = 'continue-watching-banner';
    banner.style.cssText = `
      position: fixed;
      top: 80px;
      right: 20px;
      background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
      border-left: 4px solid #e50914;
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.6);
      z-index: 1000;
      max-width: 350px;
      font-family: "Netflix Sans", "Helvetica Neue", Arial, sans-serif;
    `;
    
    const latestVideo = inProgress[0];
    const remaining = latestVideo.duration - latestVideo.lastPosition;
    
    banner.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
        <h4 style="margin: 0; color: #e50914; font-size: 14px;">‚ñ∂Ô∏è Continuar Assistindo</h4>
        <button onclick="this.parentElement.parentElement.remove()" style="background: none; border: none; color: #999; cursor: pointer; font-size: 18px;">√ó</button>
      </div>
      <div style="color: #fff; font-size: 14px; margin-bottom: 8px; font-weight: bold;">${latestVideo.contentName}</div>
      <div style="color: #aaa; font-size: 12px; margin-bottom: 10px;">
        Parado em ${formatTime(latestVideo.lastPosition)} 
        <span style="color: #666;">(${latestVideo.percentage.toFixed(0)}%)</span>
      </div>
      <button onclick="resumeVideo('${latestVideo.videoUrl}', '${latestVideo.contentName.replace(/'/g, "\\'")}')" 
              style="background: #e50914; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 13px; width: 100%; font-weight: bold;">
        ‚ñ∂Ô∏è Continuar
      </button>
    `;
    
    document.body.appendChild(banner);
    
    // Auto-hide after 10 seconds
    setTimeout(() => {
      if (banner.parentElement) {
        banner.style.opacity = '0';
        banner.style.transition = 'opacity 0.5s';
        setTimeout(() => banner.remove(), 500);
      }
    }, 10000);
  }
  
  // Resume video from saved position
  async function resumeVideo(videoUrl, contentName) {
    const progress = await loadVideoProgress(videoUrl);
    
    // Remove banner
    const banner = document.getElementById('continue-watching-banner');
    if (banner) banner.remove();
    
    // Open player
    exibirPlayer(videoUrl, { name: contentName }, 'api');
    
    // Restore position after video loads
    if (progress && progress.lastPosition > 0) {
      const player = document.getElementById('player');
      player.addEventListener('loadedmetadata', function onLoaded() {
        player.currentTime = progress.lastPosition;
        player.removeEventListener('loadedmetadata', onLoaded);
        console.log(`V√≠deo retomado em: ${formatTime(progress.lastPosition)}`);
      });
    }
  }

  // Open modal with all videos in progress
  async function openContinueWatchingModal() {
    const savedVideos = await getAllSavedProgress();
    const inProgress = savedVideos.filter(v => v.percentage > 1 && v.percentage < 95);
    
    if (inProgress.length === 0) {
      alert('Nenhum v√≠deo em progresso encontrado.');
      return;
    }
    
    const modal = document.createElement('div');
    modal.id = 'continue-modal';
    modal.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: "Netflix Sans", "Helvetica Neue", Arial, sans-serif;
    `;
    
    const content = document.createElement('div');
    content.style.cssText = `
      background: #1a1a1a;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
    `;
    
    let videosHtml = inProgress.map(video => `
      <div style="background: #2a2a2a; padding: 15px; border-radius: 8px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #e50914;">
        <div style="flex: 1;">
          <div style="font-weight: bold; color: #fff; margin-bottom: 5px; font-size: 14px;">${video.contentName}</div>
          <div style="font-size: 12px; color: #888;">
            <span style="color: #e50914;">‚ñ∂ ${formatTime(video.lastPosition)}</span> 
            de ${formatTime(video.duration)} 
            <span style="color: #666;">(${video.percentage.toFixed(0)}%)</span>
          </div>
          <div style="font-size: 11px; color: #666; margin-top: 3px;">
            √öltima vez: ${new Date(video.lastUpdated).toLocaleString('pt-BR')}
          </div>
        </div>
        <div style="display: flex; gap: 8px; margin-left: 15px;">
          <button onclick="resumeVideo('${video.videoUrl}', '${video.contentName.replace(/'/g, "\\'")}'); document.getElementById('continue-modal').remove();" 
                  style="padding: 8px 15px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: bold;">
            ‚ñ∂ Continuar
          </button>
          <button onclick="deleteVideoProgress('${video.videoUrl}'); this.parentElement.parentElement.remove();" 
                  style="padding: 8px 15px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
            üóëÔ∏è
          </button>
        </div>
      </div>
    `).join('');
    
    content.innerHTML = `
      <div style="background: #e50914; padding: 20px; display: flex; justify-content: space-between; align-items: center;">
        <h2 style="margin: 0; color: white; font-size: 1.5em;">üì∫ Continuar Assistindo</h2>
        <button onclick="document.getElementById('continue-modal').remove()" style="background: transparent; border: none; color: white; font-size: 24px; cursor: pointer;">√ó</button>
      </div>
      <div style="padding: 20px; max-height: calc(80vh - 80px); overflow-y: auto;">
        <p style="color: #888; margin-bottom: 15px; font-size: 13px;">
          ${inProgress.length} v√≠deo(s) em progresso encontrado(s).
        </p>
        <div style="display: flex; flex-direction: column;">
          ${videosHtml}
        </div>
      </div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
  }

  function organizarPorCategoria(lista) {
    const categorias = {};
    lista.forEach(item => {
      const cat = item.category_name || "Outros";
      if (!categorias[cat]) categorias[cat] = [];
      if (!categorias[cat].some(i => i.name === item.name)) {
        categorias[cat].push(item);
      }
    });
    return categorias;
  }

  function registrarUltimo(item) {
    let ultimos = JSON.parse(localStorage.getItem("ultimos") || "[]");
    ultimos = ultimos.filter(i => i.name !== item.name);
    ultimos.unshift(item);
    if (ultimos.length > 50) ultimos.pop();
    localStorage.setItem("ultimos", JSON.stringify(ultimos));
  }

  function alternarFavorito(item) {
    const idx = favoritos.findIndex(i => i.name === item.name);
    if (idx >= 0) favoritos.splice(idx, 1);
    else favoritos.unshift(item);
    localStorage.setItem("favoritos", JSON.stringify(favoritos));
  }

  function resetarAbas() {
    homeBtn.classList.remove("active");
    filmesBtn.classList.remove("active");
    seriesBtn.classList.remove("active");
    favoritosBtn.classList.remove("active");
  }

  function renderItens(lista, isFilme = true) {
    const grid = document.createElement("div");
    grid.className = "grid";
    
    lista.forEach(item => {
      const el = document.createElement("div");
      el.className = "item";

      const capa = isFilme ? item.stream_icon : item.cover;
      const isFav = favoritos.some(f => f.name === item.name);

      el.innerHTML = `
        <div class="img-container">
          <img loading="lazy" src="${capa || ""}" onerror="this.style.display=\'none\'">
          <span class="fav-btn" title="Favoritar">${isFav ? "‚òÖ" : "‚òÜ"}</span>
        </div>
        <p>${item.name}</p>
      `;

      el.querySelector(".img-container").onclick = () => 
        isFilme 
          ? exibirPlayer(`${streamBase}${item.stream_id}.mp4`, item)
          : abrirSerieDetalhe(item.series_id, item.name);

      el.querySelector(".fav-btn").onclick = (e) => {
        e.stopPropagation();
        alternarFavorito(item);
        e.target.textContent = favoritos.some(f => f.name === item.name) ? "‚òÖ" : "‚òÜ";
      };

      grid.appendChild(el);
    });
    return grid;
  }

  function abrirFilmes() {
    ocultarPlayer();
    resetarAbas();
    filmesBtn.classList.add("active");
    conteudoDiv.innerHTML = `<div style="padding: 20px;"><h2 class="category-title">Filmes <button class=\'btn-voltar\' onclick=\'renderTelaPrincipal()\'>Voltar</button></h2></div>`;
    conteudoDiv.appendChild(renderItens(Object.values(filmes).flat(), true));
  }

  function abrirSeries() {
    ocultarPlayer();
    resetarAbas();
    seriesBtn.classList.add("active");
    conteudoDiv.innerHTML = `<div style="padding: 20px;"><h2 class="category-title">S√©ries <button class=\'btn-voltar\' onclick=\'renderTelaPrincipal()\'>Voltar</button></h2></div>`;
    conteudoDiv.appendChild(renderItens(Object.values(series).flat(), false));
  }

  function abrirFavoritos() {
    ocultarPlayer();
    resetarAbas();
    favoritosBtn.classList.add("active");
    conteudoDiv.innerHTML = `<div style="padding: 20px;"><h2 class="category-title">Favoritos <button class=\'btn-voltar\' onclick=\'renderTelaPrincipal()\'>Voltar</button></h2></div>`;
    let ultimos = JSON.parse(localStorage.getItem("ultimos") || "[]");
    conteudoDiv.appendChild(renderItens(favoritos));
  }

  async function abrirSerieDetalhe(seriesId, seriesName) {
    ocultarPlayer();
    conteudoDiv.innerHTML = `<div style="padding: 20px;"><h2 class="category-title">${seriesName} <button class=\'btn-voltar\' onclick=\'abrirSeries()\'>Voltar para S√©ries</button></h2><div id=\'episodes-list\'>Carregando epis√≥dios...</div></div>`;

    try {
      const token = `username=${userG}&password=${passG}`;
      const response = await fetch(`${urlG}/player_api.php?${token}&action=get_series_info&series_id=${seriesId}`);
      const data = await response.json();

      const episodesList = document.getElementById("episodes-list");
      episodesList.innerHTML = "";

      if (data.episodes && Object.keys(data.episodes).length > 0) {
        for (const seasonNum in data.episodes) {
          const season = data.episodes[seasonNum];
          const seasonDiv = document.createElement("div");
          seasonDiv.innerHTML = `<h3 class="season-title">Temporada ${seasonNum}</h3>`;
          
          season.forEach(episode => {
            const episodeBtn = document.createElement("button");
            episodeBtn.className = "episodes";
            episodeBtn.textContent = `S${episode.season}E${episode.episode} - ${episode.title}`;
            episodeBtn.onclick = () => exibirPlayer(`${streamBase}${episode.id}.mp4`, episode);
            seasonDiv.appendChild(episodeBtn);
          });
          episodesList.appendChild(seasonDiv);
        }
      } else {
        episodesList.innerHTML = "<p style=\'text-align: center; color: var(--netflix-light-gray); padding: 40px;\'>Nenhum epis√≥dio encontrado para esta s√©rie.</p>";
      }

    } catch (e) {
      console.error("Erro ao carregar detalhes da s√©rie:", e);
      conteudoDiv.innerHTML = "<p style=\'color:var(--netflix-red); padding: 20px;\'>Erro ao carregar detalhes da s√©rie.</p>";
    }
  }

  async function renderTelaPrincipal(forceUpdate = false) {
    ocultarPlayer();
    resetarAbas();
    homeBtn.classList.add("active");
    conteudoDiv.innerHTML = 
      `<div style="text-align: center; padding: 50px;"><div class="loading-spinner"></div><p style="margin-top: 20px; color: var(--netflix-light-gray);">Carregando...</p></div>`;

    try {
      let vods = [];
      let sers = [];
      let fromCache = false;

      // Initialize DB if not already done
      if (!db) await initDB();

      if (!forceUpdate) {
        // Try to load from IndexedDB first
        try {
          vods = await loadFromDB('filmes');
          sers = await loadFromDB('series');
          
          if (vods.length > 0 || sers.length > 0) {
            fromCache = true;
            console.log(`Carregado do cache: ${vods.length} filmes, ${sers.length} s√©ries`);
          }
        } catch (dbError) {
          console.log('Erro ao carregar do cache:', dbError);
        }
      }

      // If no data in cache or force update, fetch from API
      if (!fromCache || forceUpdate) {
        conteudoDiv.innerHTML = 
          `<div style="text-align: center; padding: 50px;"><div class="loading-spinner"></div><p style="margin-top: 20px; color: var(--netflix-light-gray);">${forceUpdate ? 'Atualizando dados...' : 'Buscando dados da API...'}</p></div>`;

        const token = `username=${userG}&password=${passG}`;
        const filmesPromise = fetch(`${urlG}/player_api.php?${token}&action=get_vod_streams`).then(r => r.json());
        const seriesPromise = fetch(`${urlG}/player_api.php?${token}&action=get_series`).then(r => r.json());

        [vods, sers] = await Promise.all([filmesPromise, seriesPromise]);

        // Save to IndexedDB
        try {
          await saveToDB('filmes', vods);
          await saveToDB('series', sers);
          await saveMetadata('lastUpdate', new Date().toISOString());
          console.log('Dados salvos no cache local');
        } catch (saveError) {
          console.log('Erro ao salvar no cache:', saveError);
        }
      }

      streamBase = `${urlG}/movie/${userG}/${passG}/`;
      filmes = organizarPorCategoria(vods);
      series = organizarPorCategoria(sers);

      // Update UI
      await updateLastUpdateInfo();

      await renderizarConteudo();

    } catch (e) {
      console.error("Erro ao carregar dados da API:", e);
      
      // Try to load from cache as fallback
      try {
        if (!db) await initDB();
        const vods = await loadFromDB('filmes');
        const sers = await loadFromDB('series');
        
        if (vods.length > 0 || sers.length > 0) {
          streamBase = `${urlG}/movie/${userG}/${passG}/`;
          filmes = organizarPorCategoria(vods);
          series = organizarPorCategoria(sers);
          
          await updateLastUpdateInfo();
          
          // Show offline warning before rendering
          const offlineWarning = document.createElement('div');
          offlineWarning.style.cssText = 'background: rgba(229, 9, 20, 0.8); color: white; padding: 10px; text-align: center; font-size: 0.9rem;';
          offlineWarning.innerHTML = 'Modo offline - Exibindo dados salvos localmente <span class="offline-badge">OFFLINE</span>';
          
          await renderizarConteudo(offlineWarning);
        } else {
          throw new Error('Sem dados em cache');
        }
      } catch (cacheError) {
        conteudoDiv.innerHTML = `<p style='color:var(--netflix-red); text-align:center; padding: 50px;'>Erro ao carregar filmes e s√©ries.<br><br>Verifique sua conex√£o com a internet.<br><br><small>Erro t√©cnico: ${e.message}</small></p>`;
      }
    }
  }

  async function renderizarConteudo(offlineWarning = null) {
    conteudoDiv.innerHTML = "";
    
    if (offlineWarning) {
      conteudoDiv.appendChild(offlineWarning);
    }

    const heroBanner = document.createElement("div");
      heroBanner.className = "hero-banner";
      heroBanner.innerHTML = `
        <div class="hero-content">
          <h1 class="hero-title">LisoFlix</h1>
          <p class="hero-description">Assista aos melhores filmes e s√©ries em alta qualidade. Entretenimento ilimitado na palma da sua m√£o.</p>
          <div class="hero-buttons">
            <button class="btn-play" onclick="abrirFilmes()">Assistir Agora</button>
            <button class="btn-info" onclick="abrirSeries()">Mais Informa√ß√µes</button>
          </div>
        </div>
      `;
      conteudoDiv.appendChild(heroBanner);

      if (Object.keys(filmes).length) {
        const secFilmes = document.createElement("div");
        secFilmes.className = "category";
        secFilmes.innerHTML = `<h2 class="category-title">Filmes em Destaque</h2>`;
        const filmesRow = document.createElement("div");
        filmesRow.className = "carousel";
        
        let filmesAdicionados = 0;
        Object.keys(filmes).forEach(cat => {
          if (filmesAdicionados >= 15) return;
          filmes[cat].slice(0, Math.min(10, 15 - filmesAdicionados)).forEach(f => {
            const item = document.createElement("div");
            item.className = "item";
            const isFav = favoritos.some(fav => fav.name === f.name);
            item.innerHTML = `
              <div class="img-container">
                <img loading="lazy" src="${f.stream_icon || ""}" onerror="this.style.display=\'none\'">
                <span class="fav-btn" title="Favoritar">${isFav ? "‚òÖ" : "‚òÜ"}</span>
              </div>
              <p>${f.name}</p>
            `;
            
            item.querySelector(".fav-btn").onclick = (e) => {
              e.stopPropagation();
              alternarFavorito(f);
              e.target.textContent = favoritos.some(fav => fav.name === f.name) ? "‚òÖ" : "‚òÜ";
            };
            item.querySelector(".img-container").onclick = () => exibirPlayer(`${streamBase}${f.stream_id}.mp4`, f);
            filmesRow.appendChild(item);
            filmesAdicionados++;
          });
        });
        secFilmes.appendChild(filmesRow);
        conteudoDiv.appendChild(secFilmes);

        const catDesenhos = Object.keys(filmes).find(c => /desenho|anima√ß|infantil/i.test(c));
        if (catDesenhos) {
          const secDesenhos = document.createElement("div");
          secDesenhos.className = "category";
          secDesenhos.innerHTML = `<h2 class="category-title">Desenhos</h2>`;
          const desenhosRow = document.createElement("div");
          desenhosRow.className = "carousel";
          filmes[catDesenhos].slice(0, 15).forEach(f => {
            const item = document.createElement("div");
            item.className = "item";
            const isFav = favoritos.some(fav => fav.name === f.name);
            item.innerHTML = `
              <div class="img-container">
                <img loading="lazy" src="${f.stream_icon || ""}" onerror="this.style.display=\'none\'">
                <span class="fav-btn" title="Favoritar">${isFav ? "‚òÖ" : "‚òÜ"}</span>
              </div>
              <p>${f.name}</p>
            `;
            
            item.querySelector(".fav-btn").onclick = (e) => {
              e.stopPropagation();
              alternarFavorito(f);
              e.target.textContent = favoritos.some(fav => fav.name === f.name) ? "‚òÖ" : "‚òÜ";
            };
            item.querySelector(".img-container").onclick = () => exibirPlayer(`${streamBase}${f.stream_id}.mp4`, f);
            desenhosRow.appendChild(item);
          });
          secDesenhos.appendChild(desenhosRow);
          conteudoDiv.appendChild(secDesenhos);
        }
      }

      if (Object.keys(series).length) {
        const secSeries = document.createElement("div");
        secSeries.className = "category";
        secSeries.innerHTML = `<h2 class="category-title">S√©ries em Destaque</h2>`;
        const seriesRow = document.createElement("div");
        seriesRow.className = "carousel";
        
        let seriesAdicionadas = 0;
        Object.keys(series).forEach(cat => {
          if (seriesAdicionadas >= 15) return;
          series[cat].slice(0, Math.min(10, 15 - seriesAdicionadas)).forEach(s => {
            const item = document.createElement("div");
            item.className = "item";
            const isFav = favoritos.some(fav => fav.name === s.name);
            item.innerHTML = `
              <div class="img-container">
                <img loading="lazy" src="${s.cover || ""}" onerror="this.style.display=\'none\'">
                <span class="fav-btn" title="Favoritar">${isFav ? "‚òÖ" : "‚òÜ"}</span>
              </div>
              <p>${s.name}</p>
            `;
            
            item.querySelector(".fav-btn").onclick = (e) => {
              e.stopPropagation();
              alternarFavorito(s);
              e.target.textContent = favoritos.some(fav => fav.name === s.name) ? "‚òÖ" : "‚òÜ";
            };
            item.querySelector(".img-container").onclick = () => abrirSerieDetalhe(s.series_id, s.name);
            seriesRow.appendChild(item);
            seriesAdicionadas++;
          });
        });
        secSeries.appendChild(seriesRow);
        conteudoDiv.appendChild(secSeries);
      }
    }
  }

  homeBtn.addEventListener("click", renderTelaPrincipal);
  filmesBtn.addEventListener("click", abrirFilmes);
  seriesBtn.addEventListener("click", abrirSeries);
  favoritosBtn.addEventListener("click", abrirFavoritos);

  renderTelaPrincipal();
  
  // Show continue watching banner after a short delay
  setTimeout(() => {
    showContinueWatching();
  }, 3000);
</script>

</body>
</html>

